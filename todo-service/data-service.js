const MongoClient = require('mongodb').MongoClient;
const ObjectId = require('mongodb').ObjectId;

class DataService {
    constructor(configuration) {
        // Set empty and default properties
        this.tag = '[data-service]';
        this.url = '';
        this.client = null;
        this.database = null;
        this.databaseName = '';
        this.collection = 'todo';

        // Initialization
        if (!configuration)
            throw `${ this.tag } missing configuration in constructor`;

        const host = configuration.host;
        const port = configuration.port;

        this.url = `mongodb://${ host }:${ port }`;
        this.client = new MongoClient(this.url);
        this.databaseName = configuration.data;
    }

    async init() {
        if (!this.client)
            throw `${ this.tag } init: client is not available`;

        return new Promise((resolve, reject) => {
            this.client.connect(error => {
                if (error)
                    throw `${ this.tag } init: cannot connect to mongo client; ${ JSON.stringify(error) }`;

                console.log(this.tag, 'init: successfully connected to the mongo client at', this.url);

                this.database = this.client.db(this.databaseName);

                if (!this.database)
                    throw `${ this.tag } init: cannot connect to the database`;

                console.log(this.tag, 'init: successfully connected to the database', this.databaseName);

                resolve();
            });
        });
    }

    /**
     * Get one item from collection based on the provided ID.
     *
     * @param id {string}
     */
    async getOne(id) {
        return new Promise((resolve, reject) => {
            this.database.collection(this.collection).find({
                _id: ObjectId(id)
            }).toArray((error, docs) => {
                if (error)
                    return reject(error);

                const finalDocs = docs.map(el => {
                    return {
                        id: el._id,
                        jobTitle: el.jobTitle,
                        jobDescription: el.jobDescription,
                        recordCreated: el.recordCreated
                    }
                });

                resolve(finalDocs[0]);
            });
        });
    }

    /**
     * Get multiple items from collection based on the input parameters.
     *
     * @param offset {number}        Number representing how many items should be skipped.
     * @param limit {number}         Number of items to be returned.
     * @param sortKey {string}       Key based on which sort should be executed.
     * @param sortDir {'asc'|'desc'} Whether to sort items in ascending or descending order.
     * @param {search} {string}      Return only items which include search string.
     */
    async getAll(offset, limit, sortKey, sortDir, search) {
        offset = offset || 0;
        limit = limit || 5;
        sortKey = sortKey || 'id';
        sortDir = sortDir || 'asc';
        search = (search || '').toLowerCase();

        return new Promise((resolve, reject) => {
            // Search Parameters
            const searchParams = {};

            if (search !== '') {
                const regexp = new RegExp(`.*${ search }.*`);

                searchParams['$or'] = [
                    { jobTitle: regexp },
                    { jobDescription: regexp },
                    { recordCreated: regexp }
                ];
            }

            // Sort Parameters
            const sortParams = {};

            sortParams[sortKey] = sortDir === 'asc' ? 1 : -1;

            // Mongo Query
            this.database.collection(this.collection)
            .find(searchParams)
            .sort(sortParams)
            .toArray((error, docs) => {
                if (error)
                    return reject(error);

                const count = docs.length;
                const finalDocs = docs.splice(offset, limit).map(el => {
                    return {
                        id: el._id,
                        jobTitle: el.jobTitle,
                        jobDescription: el.jobDescription,
                        recordCreated: el.recordCreated
                    }
                });

                resolve({
                    totalCount: count,
                    data: finalDocs
                });
            });
        });
    }

    /**
     * Create todo item.
     *
     * @param data {
     *     id: autogenerated, // Ignored
     *     jobTitle: string,
     *     jobDescription: string,
     *     recordCreated: autogenerated // Ignored
     * }
     */
    async createTodo(data) {
        return new Promise((resolve, reject) => {
            const jobTitle = data.jobTitle;
            const jobDescription = data.jobDescription;

            this.database.collection(this.collection).insertOne({
                jobTitle,
                jobDescription,
                recordCreated: new Date().toISOString()
            }, (error, result) => {
                if (error)
                    return reject(error);

                const resultData = result.ops[0];

                resolve({
                    id: resultData._id,
                    jobTitle: resultData.jobTitle,
                    jobDescription: resultData.jobDescription,
                    recordCreated: resultData.recordCreated
                });
            });
        });
    }

    /**
     * Update existing todo item.
     *
     * @param id {string} ID representing item which should be updated.
     * @param data {
     *     jobTitle: string,
     *     jobDescription: string,
     *     recordCreated: autogenerated // ignored
     * }
     */
    async updateTodo(id, data) {
        return new Promise((resolve, reject) => {
            const jobTitle = data.jobTitle;
            const jobDescription = data.jobDescription;

            this.database.collection(this.collection).updateOne({
                _id: ObjectId(id)
            }, {
                $set: {
                    jobTitle,
                    jobDescription,
                    recordCreated: new Date().toISOString()
                }
            }, async (error, result) => {
                if (error)
                    return reject(error);

                const finalObject = await this.getOne(id);

                resolve({
                    id: finalObject._id,
                    jobTitle: finalObject.jobTitle,
                    jobDescription: finalObject.jobDescription,
                    recordCreated: finalObject.recordCreated
                });
            });
        });
    }

    /**
     * Delete one or more todo items.
     *
     * @param id {string[]} Array of IDs representing items which should be deleted.
     */
    async deleteTodo(id) {
        const deleteSingle = async id => {
            this.database.collection(this.collection).deleteOne({
                _id: ObjectId(id)
            }, (error, result) => {
                if (error)
                    throw(error);

                console.log(this.tag, 'deleteTodo: deleted item with ID', id);
            });
        }

        return new Promise(async (resolve, reject) => {
            for (const itemId of id) {
                try {
                    await deleteSingle(itemId);
                } catch (error) {
                    reject(error);
                }
            }

            resolve(true);
        });
    }
}

module.exports = DataService;
